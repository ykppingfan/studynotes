&emsp;&emsp;前面我已经介绍了有关并行程序的一些关键概念和定律。这些概念可以说是与语言无关的。无论你使用Java或者C，或者其他任何一门语言编写并发程序，都有可能会设计这些问题。但本书依然是一本面向Java程序员的书籍。因此，在本章最后，我们还是希望可以探讨一下有关Java的内存模型（JMM）。

&emsp;&emsp;由于并发程序要比串行程序复杂很多，其中一个重要原因是并发程序下数据访问的一致性和安全性将会受到严重挑战。如何保证一个线程可以看到正确的数据呢？这个问题看起来很白痴。对于串行程序来说，根本就是小菜一碟，如果你读取一个变量，这个变量的值是1，那么你读到的一定是1，就这么简单的问题在并行程序中居然变得复杂起来。事实上，如果不加控制地任由线程胡乱并行，即使原本是1的数值，你也有可能读到2。因此，我们需要在深入了解并行机制的前提下，再定义一种规则，保证多个县城建可以有效地、正确地协同工作。而JMM也就是为此而生的。

&emsp;&emsp;JMM的关键技术点都是围绕着多线程的原子性、可见性和有序性来建立的。因此，我们首先必须了解这些概念。

## 1.5.1 原子性（Atomicity）

&emsp;&emsp;原子性是指一个操作是不可中断的。即使是在多个线程一起执行的时候，一个操作一旦开始，就不会被其他线程干扰。

&emsp;&emsp;比如，对于一个静态全局变量int i，两个县城同时对它赋值，线程A给他赋值1，线程B给他赋值为-1。那么不管这2个线程以何种方式、何种步调工作，i的值要么是1，要么是-1。线程A和线程B之间是没有干扰的。**这就是原子性的一个忒点，不可被终端**。

&emsp;&emsp;但如果我们不适用int型而使用long型的话，可能就没有那么幸运了。对于32位系统来说，long型数据的读写不是原子性（**因为long有64位**）。也就是说，如果两个线程同时对long进行写入的话（或者读取），对线程之间的结果是有干扰的。

&emsp;&emsp;大家可以仔细观察一下下面的代码：
```
public class MultiThreadLong {
    public static long t = 0;
    public static class ChangeT implements Runnable {
        private long to;
        public ChangeT(long to) {
            this.to = to;
        }
        
        @Override
        public void run() {
            while(true) {
                MultiThreadLong.t = to;
                Thread.yield();
            }
        }
    }
    
    public static class ReadT implements Runnalbe {
        @Override
        public void run() {
            while(true) {
                long tmp = MultiThreadLong.t;
                if(tmp != 111L && tmp != -999L && tmp != 333L && tmp!= -444L)
                    System.out.println(tmp);
                Thread.yield();
            }
        }
    }
    
    public static void main(String[] args) {
        new Thread(new ChangeT(111L).start();
        new Thread(new ChangeT(-999L).start();
        new Thread(new ChangeT(333L).start();
        new Thread(new ChangeT(-444L).start();
        new Thread(new ReadT().start();
    }
}
```
&emsp;&emsp;上述代码有4个线程对long型数据t进行赋值，分别对t赋值为111、-999、333、444。然后，有一个读取线程，读取这个t的值。一般来说，t的值总是这4个数值中的一个。这当然也是我们的期望了。但很不幸，在32位的Java虚拟机中，未必总是这样。

&emsp;&emsp;如果读取线程ReadT总是读到合理的数据，那么这个程序应该没有任何输出。但是，实际上，这个程序一旦运行，就会大量输出以下信息：（再次强调，**使用32位虚拟机**）
```
......
-4294966963
4294966852
-4294966963
......
```
&emsp;&emsp;这里截取了部分输出。我们可以看到，读取线程居然读到了两个似乎根本不可能存在的数值。这不是幻觉，在这里，你看到的确实是事实，其中的原因也就是因为32位系统中long型数据的读和写都不是原子性的，多线程之间相互干扰了！

&emsp;&emsp;补码内容 略！

&emsp;&emsp;上面显示了这几组相关数字的补码形式，也就是在计算机内的真实存储内容。不难发现，这个奇怪的4294966852，其实是111或者333的钱32为，与-444的后32位夹杂后的数字。而-4294967185只是-999或者-444的前32位与111夹杂后的数字。换句话说，由于并行的关系，数字被写乱了，或者读的时候，读串位了。

&emsp;&emsp;通过这个例子，我想大家都对原子性应该有了基本的认识。