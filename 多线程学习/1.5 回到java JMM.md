&emsp;&emsp;前面我已经介绍了有关并行程序的一些关键概念和定律。这些概念可以说是与语言无关的。无论你使用Java或者C，或者其他任何一门语言编写并发程序，都有可能会设计这些问题。但本书依然是一本面向Java程序员的书籍。因此，在本章最后，我们还是希望可以探讨一下有关Java的内存模型（JMM）。

&emsp;&emsp;由于并发程序要比串行程序复杂很多，其中一个重要原因是并发程序下数据访问的一致性和安全性将会受到严重挑战。如何保证一个线程可以看到正确的数据呢？这个问题看起来很白痴。对于串行程序来说，根本就是小菜一碟，如果你读取一个变量，这个变量的值是1，那么你读到的一定是1，就这么简单的问题在并行程序中居然变得复杂起来。事实上，如果不加控制地任由线程胡乱并行，即使原本是1的数值，你也有可能读到2。因此，我们需要在深入了解并行机制的前提下，再定义一种规则，保证多个县城建可以有效地、正确地协同工作。而JMM也就是为此而生的。

&emsp;&emsp;JMM的关键技术点都是围绕着多线程的原子性、可见性和有序性来建立的。因此，我们首先必须了解这些概念。

## 1.5.1 原子性（Atomicity）

&emsp;&emsp;原子性是指一个操作是不可中断的。即使是在多个线程一起执行的时候，一个操作一旦开始，就不会被其他线程干扰。

&emsp;&emsp;比如，对于一个静态全局变量int i，两个县城同时对它赋值，线程A给他赋值1，线程B给他赋值为-1。那么不管这2个线程以何种方式、何种步调工作，i的值要么是1，要么是-1。线程A和线程B之间是没有干扰的。**这就是原子性的一个忒点，不可被终端**。

&emsp;&emsp;但如果我们不适用int型而使用long型的话，可能就没有那么幸运了。对于32位系统来说，long型数据的读写不是原子性（**因为long有64位**）。也就是说，如果两个线程同时对long进行写入的话（或者读取），对线程之间的结果是有干扰的。

&emsp;&emsp;大家可以仔细观察一下下面的代码：
```
public class MultiThreadLong {
    public static long t = 0;
    public static class ChangeT implements Runnable {
        private long to;
        public ChangeT(long to) {
            this.to = to;
        }
        
        @Override
        public void run() {
            while(true) {
                MultiThreadLong.t = to;
                Thread.yield();
            }
        }
    }
    
    public static class ReadT implements Runnalbe {
        @Override
        public void run() {
            while(true) {
                long tmp = MultiThreadLong.t;
                if(tmp != 111L && tmp != -999L && tmp != 333L && tmp!= -444L)
                    System.out.println(tmp);
                Thread.yield();
            }
        }
    }
    
    public static void main(String[] args) {
        new Thread(new ChangeT(111L).start();
        new Thread(new ChangeT(-999L).start();
        new Thread(new ChangeT(333L).start();
        new Thread(new ChangeT(-444L).start();
        new Thread(new ReadT().start();
    }
}
```
&emsp;&emsp;上述代码有4个线程对long型数据t进行赋值，分别对t赋值为111、-999、333、444。然后，有一个读取线程，读取这个t的值。一般来说，t的值总是这4个数值中的一个。这当然也是我们的期望了。但很不幸，在32位的Java虚拟机中，未必总是这样。

&emsp;&emsp;如果读取线程ReadT总是读到合理的数据，那么这个程序应该没有任何输出。但是，实际上，这个程序一旦运行，就会大量输出以下信息：（再次强调，**使用32位虚拟机**）
```
......
-4294966963
4294966852
-4294966963
......
```
&emsp;&emsp;这里截取了部分输出。我们可以看到，读取线程居然读到了两个似乎根本不可能存在的数值。这不是幻觉，在这里，你看到的确实是事实，其中的原因也就是因为32位系统中long型数据的读和写都不是原子性的，多线程之间相互干扰了！

&emsp;&emsp;补码内容 略！

&emsp;&emsp;上面显示了这几组相关数字的补码形式，也就是在计算机内的真实存储内容。不难发现，这个奇怪的4294966852，其实是111或者333的钱32为，与-444的后32位夹杂后的数字。而-4294967185只是-999或者-444的前32位与111夹杂后的数字。换句话说，由于并行的关系，数字被写乱了，或者读的时候，读串位了。

&emsp;&emsp;通过这个例子，我想大家都对原子性应该有了基本的认识。

## 1.5.2 可见性（Visibility）

&emsp;&emsp;**可见性**是指当一个线程修改了某一个共享变量的值，其他线程是否能够立即知道这个修改。显然，对于串行程序来说，可见性问题是不存在的。因为你在任何一个操作步骤中修改了某个变量，那么在后续的步骤中，读取这个变量的值，一定是修改后的新值。

&emsp;&emsp;但是这个问题在并行程序中就不见得了。如果一个线程修改了某一个全局变量，那么其他线程未必可以马上知道这个改动。如果在CPU1和CPU2上各运行了一个线程，他们共享变量t，由于编译器优化或者硬件优化的缘故，在CPU1上的线程将变量t进行了优化，**将其缓存在cache中或者寄存器里。这种情况下，如果在CPU2上的某个线程修改了变量t的实际值，那么CPU1上的线程可能并无法意识到这个改动，依然会读取cache中或者寄存器里的数据。因此，就产生了可见性问题。外在表现为：变量t的值被修改，但是CPU1上的线程依然会读到一个旧值。可见性问题也是并行程序开发中需要重点关注的问题之一。

&emsp;&emsp;可见性问题是一个综合性问题。除了上述提到的缓存优化或者硬件优化（有些内存读写可能不会立即触发，而会先进入一个硬件队列等待）会导致可见性问题外，指令重排（这个问题将在下一节中更详细讨论）以及编辑器的优化，都有可能导致一个线程的修改不会立即被其他线程察觉。

&emsp;&emsp;下面来看一个简单的例子：
```
Thread 1 Thread 2
1:r2 = A; 3: r1 = B;
2:B = 1; 4: A = 2;
```
&emsp;&emsp;上述两个线程，并行执行，分别有1、2、3、4四条指令。其中指令1、2属于线程1，而指令3、4属于线程2.

&emsp;&emsp;从指令的执行顺序上看，r2 == 2并且r1 == 1 似乎是不可能出现的。但实际上，我们并没有办法从理论上保证这种情况不出现。因为编译器可能将指令重排成：
```
Thread 1 Thread 2
B = 1; r1 = B;
r2 = A; A = 2;
```
&emsp;&emsp;在这种执行顺序中，就有可能出现刚才看似不可能出现的r2 == 2 并且 r1 == 1 的情况了。

&emsp;&emsp;这个例子就说明，在一个线程中去观察另外一个线程的变量，他们的值是否能观测到、何时能观测到是没有保证的。

&emsp;&emsp;再来看一个稍微复杂一些的例子：
```
Thread 1 Thread 2
r1 = p; r6 = p;
r2 = r1.x; r6.x = 3;
r3 = q;
r4 = r3.x;
r5 = r1.x;
```
&emsp;&emsp;这里假设在初始时，p == q并且p.x == 0。对于大部分编译器来说，可能会对线程1进行向前替换的优化，也就是r5=r1.x这条指令会被直接替换成r5=r2。因为它们都读取了r1.x，**又发生在同一个线程中**，因此，编译器很可能认为第2次读取是完全没有必要的。因此，上述指令可能会变成：
```
Thread 1 Thread 2
r1 = p; r6 = p;
r2 = r1.x; r6.x = 3;
r3 = q;
r4 = r3.x;
r5 = r2;
```
&emsp;&emsp;现在思考这么一种场景。假设线程2中的r6.x=3发生在r2=r1.x和r4=r3.x之间，而编译器又打算重用r2来表示r5。那么就有可能会出现非常奇怪的现象。你看到的r2是0，r4是3，但是r5还是0。因此，如果从线程1代码的直观感觉上看就是：p.x的值从0变成了3（因为r4是3），接着又变成了0（这是不是算一个非常怪异的问题呢？）。