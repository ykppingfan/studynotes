&emsp;&emsp;由于临界区的存在，多线程之间的并发必须受到控制。根据控制并发的策略，我们可以把并发的级别进行分类，大致上可以分为阻塞、无饥饿、无障碍、无锁、无等待几种。

## 1.3.1 阻塞（Blocking）

&emsp;&emsp;一个线程是阻塞的，那么在其他线程释放资源之前，当前线程无法继续执行。当我们使用synchronized关键字，或者重入锁时（我们将在第2、3章介绍这两种技术），我们得到的就是阻塞的线程。

&emsp;&emsp;无论是synchronized或者重入锁，都会试图在执行后续代码前，得到临界区的锁，如果得不到，线程就会被挂起等待，直到占有了所需资源为止。

## 1.3.2 无饥饿（Starvation-Free）

&emsp;&emsp;如果县城之间是有优先级的，那么线程调度的时候总是会倾向于满足高优先级的线程。也就是说，对于同一个资源的分配，是**不公平**的！对于非公平的锁来说，系统允许高优先级的线程插队。这样有可能导致低优先级的线程产生饥饿。但如果锁是**公平的**，满足先来后到，那么饥饿就不会产生，不管新来的线程优先级多高，要想获得资源，就必须乖乖排队。那么所有的线程都会有机会执行。

## 1.3.3 无障碍（Obstruction-Free）

&emsp;&emsp;**无障碍是一种最弱的非阻塞调度**。两个线程如果是无障碍的执行，那么他们不会因为临界区的问题导致一方被挂起。换言之，大家都可以大摇大摆的进入临界区了。那么如果大家一起修改共享数据，把数据改坏了可怎么办呢？**对于无障碍的线程来说，一旦检测到这种情况，它就会立即对自己所做的修改进行回滚，确保数据安全**。但是如果没有数据竞争发生，那么线程就可以顺利完成自己的工作，走出临界区。

&emsp;&emsp;如果说阻塞的控制方式是悲观策略。也就是说，系统认为两个线程之间很有可能发生不幸的冲突，因此，以保护共享数据为第一优先级。相对来说，非阻塞的调度就是一种乐观的策略。它认为多个线程之间很有可能不会发生冲突，或者说这种概率不大。因此大家都应该无障碍的执行，但是一旦检测到冲突，就应该进行回滚。

&emsp;&emsp;从这个策略中也可以看到，无障碍的多线程程序并不一定能顺畅的运行。因为当临界区中存在严重的冲突时，所有的线程可能都会不断地回滚自己的操作，而没有一个线程可以走出临界区。这种情况会影响系统的正常执行。所以，我们可能会非常希望在这一堆线程中，至少有一个线程能够在有限的时间内完成自己的操作，而退出临界区。至少这样可以保证系统不会在临界区中进行无限的等待。

&emsp;&emsp;**一种可行的无障碍实现可以依赖一个“一致性标记”来实现**。线程在操作之前，先读取并保存这个标记，在操作完成后，再次读取，检查这个标记是否被更改过，如果两者是一致的，则说明资源访问没有冲突。如果不一致，则说明资源可能在操作过程中与其他写线程冲突，需要充实操作。而任何对资源有修改操作的线程，在修改数据前，都需要更新这个一致性标记，表示数据不再安全。

## 1.3.4 无锁（Lock-Free）

&emsp;&emsp;无锁的并行都是无障碍的。在无锁的情况下，所有的线程都能尝试对临界区进行访问，但不同的是，**无所得并发保证必然有一个线程能够在有限步内完成操作离开临界区**。

&emsp;&emsp;在无锁的调用中，一个典型的特点是可能会包含一个无穷循环。在这个循环中，线程会不断尝试修改共享变量。如果没有冲突，修改成功，那么程序退出，否则继续尝试修改。但无论如何，无锁的并行总能保证有一个线程是可以胜出的，不至于全军覆没。至于临界区中竞争失败的线程，它们则必须不断重试，直到自己获胜。如果运气很不好，总是尝试不成功，则会出现类似饥饿的线程，线程会停止不前。

&emsp;&emsp;下面就是一段无锁的示意代码，如果修改不成功，那么循环永不停止。

```
while (!atomicVar.compareAndSet(localVar,localVar+1)) {
    localVar = atomicVar.get();
}
```
&emsp;&emsp;有关无锁，我们将安排在“锁的优化与注意事项”一章中详细介绍。

## 1.3.5 无等待（Wait-Free)

&emsp;&emsp;无锁只要求有一个线程可以在有限步内完成操作，而无等待则在无锁的基础上更进一步进行扩展。**它要求所有的线程都必须在有限步内完成**，这样就不会引起饥饿问题。如果限制这个步骤上限，还可以进一步分解为有界无等待和线程数无关的无等待几种，他们之间的区别只是对循环次数的限制不同。

&emsp;&emsp;一种典型的无等待结构就是RCU(Read-Copy-Update)。它的基本思想是，对数据的读可以不加控制。因此，所有的读线程都是无等待的，它们既不会被锁定等待也不会引起任何冲突。但在写数据的时候，先取得原始数据的副本，接着只修改副本数据（这就是为什么读可以不加控制），修改完成后，在核实的实际回写数据。