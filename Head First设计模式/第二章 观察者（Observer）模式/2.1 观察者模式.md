&emsp;&emsp;有一个模式可以帮你的对象知悉现况，不会错误该对象感兴趣的事。对象甚至在运行时可决定是否要继续呗通知。观察者模式是JDK中使用最多的模式之一，非常有用。

&emsp;&emsp;气象监测应用的概况

&emsp;&emsp;此系统中的三个部分是气象站（获取实际气象数据的物理装置）、WeatherData对象（追踪来自气象站的数据，并更新布告板）和布告板（显示目前天气状况给用户看）。

&emsp;&emsp;WeatherData对象知道如何跟屋里气象站联系，以取得更新的数据。WeatherData对象会随即更新三个布告板的显示：目前状况（温度、湿度、气压）、气象统计和天气预报。

&emsp;&emsp;如果我们选择接受这个项目，我们的工作就是建立一个应用，利用WeatherData对象取得数据，并更新三个布告板：目前状况气象统计和天气预报。

&emsp;&emsp;我们目前知道些什么呢？

- WeatherData类具有getter方法，可以取得三个测量值：温度、湿度与气压。
- 当新的测量数据备妥时，measurementsChanged()方法就会被调用。
- 我们需要实现三个使用天气数据的布告板：“目前状况”不高、“气象统计”不高、“天气预报”布告。一旦WeatherData有新的测量，这些布告必须马上更新。
- 此系统必须可扩展，让其他开发人员建立定制的布告板，用户可以随身所欲的添加或删除任何布告板。目前初始的布告板有三类：“目前状态”布告、“气象统计”布告、“天气预报”布告
```
public void measurementsChanged() {
    float temp = getTemperature();
    float humidity = getHumidity();
    float pressure = getPressure();
    
    currentConditionsDisplay.update(temp,humidity,pressure);
    statisticsDisplay.update(temp,humidity,pressure);
    forecastDisplay.update(temp,huidity,pressure);
}
```
## 2.1.1 认识观察者模式

&emsp;&emsp;我们看看报纸和杂志的订阅是怎么回事：

1. 报社的业务就是出版报纸。
2. 向某家报社订阅报纸，只要他们有新报纸出版，就会给你送来。只要你是他们的订户，你就会一直受到新报纸。
3. 当你不想再看报纸的时候，取消订阅，他们留不会再送新报纸来。
4. 只要报社还在运营，就会一直有人（或单位）向他们订阅报纸或取消订阅报纸。

### 出版者+订阅者=观察者模式

如果你了解报纸的订阅是怎么回事，其实就知道观察者模式是怎么回事，只是名称不太一样：出版者改称为“主题”（Subject），订阅者改称为“观察者”（Observer）。

&emsp;&emsp;主题对象管理某些数据，当主题内的数据改变，就会通知观察者，观察者已经订阅（注册）主题以便在主题数据改变时能够收到更新。

&emsp;&emsp;观察者模式的一天

&emsp;&emsp;鸭子对象过来告诉主题，它想当一个观察者。

&emsp;&emsp;鸭子其实想说的是：我对你的数据改变感兴趣，已有变化请通知我

&emsp;&emsp;鸭子对象现在已经是正式的观察者了。

&emsp;&emsp;鸭子静候通知，等待参与这项伟大的事情。一旦接获通知，就会得到一个整数。

&emsp;&emsp;主题有了新的数据值

&emsp;&emsp;现在鸭子和其他所有馆缠着都会受到通知：主题已经改变了

&emsp;&emsp;老鼠对象要求从观察者中把自己除名。

&emsp;&emsp;老鼠已经观察此主题太久，厌倦了，所以决定不再当个观察者。

&emsp;&emsp;老鼠离开了

&emsp;&emsp;主题知道老鼠的请求之后，把它从观察者中除名。

&emsp;&emsp;主题有一个新的整数

&emsp;&emsp;除了老鼠之外，每个观察者都会收到通知，因为它已经被除名了。嘘！不要告诉别人，老鼠其实心中暗暗地怀念这些整数，或许哪天又会再次注册，回来继续当观察者呢！

## 2.1.2 定义观察者模式

&emsp;&emsp;观察者模式：定义了对象之间的一对多依赖，这样依赖，当一个对象改变状态时，它的所有依赖者都会受到通知并自动更新。

&emsp;&emsp;烧毁你会看到，实现观察者模式的方法不只一种，但是以包含Subject和Observer接口的类设计的做法最常见。
```
public interface Subject {
    registerObserver();
    removeObserver();
    notifyObservers();
    
}

public interface Observer {
    update();
}
```
## 2.1.3 松耦合的威力

&emsp;&emsp;当两个对象之间松耦合，它们依然可以交互，但是不太清楚彼此的细节。观察者模式提供了一种对象设计，让主题和观察者之间松耦合。为什么呢？

&emsp;&emsp;关于观察者的一切，主题只知道观察者实现了某个接口（也就是Observer接口）。主题不需要知道观察者的具体类是谁、做了些什么或其他任何细节。

&emsp;&emsp;任何时候我们都可以增加新的观察者。因为主题唯一依赖的东西是一个实现Observer接口的对象列表，所以我们可以随时增加观察者。事实上，在运行时我们可以用新的观察者取代现有的观察者，主题不会受到任何影响。同样的，也可以在任何时候删除某些观察者。

### 设计原则：为了交互对象之间的松耦合设计而努力。松耦合的设计之所以能让我们建立有弹性的OO系统，能够应对变化，是因为对象之间的互相依赖降到了最低。

## 2.1.4 使用Java内置的观察者模式

&emsp;&emsp;java.util.Observer（接口）和java.util.Observable（类）

&emsp;&emsp;java.util.Observable是一个类而不是一个接口，限制了它的使用和复用。违反了设计原则“多用组合，少用继承”