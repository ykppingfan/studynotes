&emsp;&emsp;我们已经比较完整的介绍了有关无锁的概念和使用方法。相对于有锁的方法，使用无锁的方式变成更加考验一个程序员的耐心和智力。但是，无锁带来的好处也是显而易见的，第一，在高并发的情况下，它比有锁的程序拥有更好的性能：第二，它天生是死锁免疫的。就凭借这两个优势，我们就值得冒险尝试使用无锁的并发。

&emsp;&emsp;这里，我想向大家介绍一种使用无锁方式实现的Vector。通过这个案例，我们可以更加深刻的认识无锁的算法，同时也可以学习一下有关Vector实现的细节和算法技巧（在本例中，讲述的无锁Vector来自于amino并发包）。

&emsp;&emsp;我们将这个无锁的Vector成为LockFreeVector。它的特点是可以根据需求动态扩展其内部空间。在这里，我们使用二维数组来表示LockFreeVector的内部存储，如下：
```
private final AtomicReferenceArray<AtomicReferenceArray<E>> buckets;
```
&emsp;&emsp;变量buckets存放所有的内部元素。从定义上看，它是一个保存着数组的数组，也就是通常的二维数组。特别之处在于这些数组都是使用CAS的原子数组。为什么使用二维数组去实现一个一维的Vector呢？这是为了将来Vector进行动态扩展时可以更加方便。我们知道，AtomicReferenceArray内部使用Object[]来进行实际数据的存储，这使得动态空间增加特别的麻烦，因此使用二维数组的好处就是为了将来可以方便的增加新的元素。

&emsp;&emsp;此外，为了更有序的读写数组，定义一个称为Descriptor的元素。它的作用是使用CAS操作写入新数据。