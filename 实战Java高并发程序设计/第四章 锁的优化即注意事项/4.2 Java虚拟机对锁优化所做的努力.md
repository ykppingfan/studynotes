&emsp;&emsp;作为一款共用平台，JDK本身也为并发程序的性能绞尽脑汁。在JDK内部也想尽一切办法提供并发时的系统吞吐量。这里，我将向大家简单介绍几种JDK内部的“锁”的优化策略。

## 4.2.1 锁偏向

&emsp;&emsp;锁偏向是一种针对加锁操作的优化手段。它的核心思想是：如果一个线程获得了锁，那么锁就进入偏向模式。当这个线程再次请求锁时，无需再做任何同步操作。这样就节省了大量有关锁申请的操作，从而提高了程序性能。因此，对于几乎没有锁竞争的场合，偏向锁有比较好的优化效果，因为连续多次极有可能是同一个线程请求相同的锁。**而对于锁竞争比较激烈的场合，其效果不佳**。因为在竞争激烈的场合，最有可能的情况是每次都是不同的线程来请求相同的锁。这样偏向模式会失效，因此还不如不启用偏向锁。**使用Java虚拟机参数-XX:+UseBiasedLocking可以开启偏向锁**。

## 4.2.2 轻量级锁

&emsp;&emsp;如果偏向锁失败，虚拟机并不会立即挂起线程。它还会使用一种称为轻量级锁的优化手段。轻量级锁的操作也很轻便，它只是简单的将对象头部作为指针，指向持有锁的线程堆栈的内部，来判断一个线程是否持有对象锁。如果线程获得轻量级锁成功，则可以顺利进入临界区。如果轻量级锁加锁失败，则表示其他线程抢先争夺到了锁，那么当前线程的锁请求就会膨胀为**重量级锁**。

## 4.2.3 自旋锁

&emsp;&emsp;锁膨胀后，虚拟机为了避免线程真实地在操作系统层面挂起，虚拟机还会在做最后的努力--自旋锁。由于当前线程暂时无法获得锁，但是什么时候可以获得锁是一个未知数。也许在几个CPU时钟周期后，就可以得到锁。如果这样，简单粗暴的挂起线程可能是一种得不偿失的操作。因此，系统会进行一次堵住：它会假设在不久的将来，线程可以得到这把锁。因此，虚拟机会让当前线程做几个空循环（这也是自旋的含义），在经过若干次循环后，如果可以得到锁，那么就顺利进入临界区。如果还不能获得锁，才会真实的将线程在操作系统层面挂起。

## 4.2.4 锁消除

&emsp;&emsp;锁消除是一种更彻底的锁优化。Java细腻机在JIT编译时，通过对运行上下文的扫描，**去除不可能存在共享资源竞争的锁**。通过锁消除，可以节省毫无意义的请求锁时间。

&emsp;&emsp;说到这里，细心地读者可能会有疑问，如果不可能存在竞争，为什么程序员还要加上锁的？这是因为在Java软件开发过程中，我们必然会使用一些JDK的内置API，比如StringBuffer、Vector等。你在使用这些类的时候，也许你根本不会考虑这些对象到底内部是如何实现的。比如，你很有可能在一个不可能存在并发竞争的场合使用Vector。而众所周知，Vector内部使用了synchronized请求锁。比如下面的代码：
```
public String[] createStrings() {
    Vector<String> v = new Vector<>();
    for (int i=0;i<100;i++) {
        v.add(Integer.toString(i));
    }
    return v.toArray(new String[]{});
}
```
&emsp;&emsp;注意上述代码中的Vector，由于变量v只在createStrings()函数中使用，因此，它只是一个单纯的局部变量。局部变量是在线程栈上分配的，数据线程私有的数据，因此不可能被其他线程访问。所以，在这种情况下，Vector内部所有加锁同步都是没有必要的。如果虚拟机检测到这种情况，就会将这些无用的锁操作去除。

&emsp;&emsp;锁消除设计的一项关键技术为**逃逸分析**。所谓逃逸分析就是观察某一个变量是否会逃出某一个作用域。在本例中，变量v显然没有逃出createStrings()函数之外。依次为基础，虚拟机才可以大胆的将v内部的加锁操作去除。如果createStrings()返回的不是String数组，而是v本身，那么就认为变量v逃逸除了当前函数，也就是说v有可能被其他线程访问。如果这样，虚拟机就不能消除v中的操作。

&emsp;&emsp;逃逸分析必须在-server模式下进行，可以使用-XX:+DoEscapeAnalysis参数打开逃逸分析。使用-XX:+EliminateLocks参数可以打开锁消除。