&emsp;&emsp;我们已经探讨为什么必须面对并行程序这样复杂的程序设计方法，那么下面就需要静下心来，认真研究如何才能构建一个正确、简装并且高效的并行系统。本章将详细介绍有关Java并行程序的设计基础，以及一些常见的问题，希望对读者有所帮助。

# 2.1 有关线程你必须知道的事

&emsp;&emsp;在介绍县城前，我们还是先了解一下线程的“母亲”——进程。如果你有度过操作系统的课程，那你对进程一定不会陌生。在这种专业级的书籍中，应该会给出一些“官方”的解释，比如像下面这样描述：

&emsp;&emsp;进程（Process）是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。在早起面向进程设计的计算机结构中，进程是程序的基本执行实体；在当代面向线程设计的计算机结构中，进程是线程的容器。程序是指令、数据及其组织形式的描述，进程是程序的实体。

&emsp;&emsp;不过我不想把这种严谨且抽象的描述介绍给大家。用一句简单的话来说，你在windows中，看到的后缀为.exe的文件，都是一个程序。不过程序是死的，静态的。当你双击这个.exe执行的时候，这个.exe文件中的指令就会被加载，那么你就能得到一个有关这个.exe程序的一个进程。进程是“活”的，或者说是正在被执行的。

&emsp;&emsp;进程中可以容纳若干个线程。它们并不是看不见的、摸不着的，也可以使用工具看到它们。

&emsp;&emsp;那线程和进程之间究竟是一种什么样的关系呢？简单地说，进程是一个容器。比如一间漂亮的小别墅。别墅里有电视、厨房、书房、洗手间等。当然，还有一家三口住在里面。当妈妈带女儿外出游玩时，爸爸一个人在家。这时爸爸一个人在家里爱上哪里去哪里、爱干嘛干嘛，这时，爸爸就像一个线程（这个进程中只有一个活动线程），小别墅就像一个进程，家里的电视、厨房、书房就像这个进程占有的资源。当到三个人住在一起时（相当于三个线程），有时候可能就会有些小冲突，比如，当女儿占着电视机看动画片时，爸爸就不能看体育频道了，这就是线程间的资源竞争。当然，大部分时候，线程之间还是协作关系（如果我们创建线程是用来打架的，那创建它干嘛呢？）。比如，妈妈在厨房为爸爸和女儿做饭，爸爸在书房工作赚钱养家糊口，女儿在写作业，各司其职，那么这个家就是其乐融融了，相对的，这个进程也就在健康的执行。

&emsp;&emsp;用稍微专业点的术语说，线程就是轻量级进程，是程序执行的最小单位。使用多线程而不是多进程去进行并发程序的设计，是因为线程间的切换和调度的成本远远小于进程。

&emsp;&emsp;线程的所有状态都在Thread中的State枚举中定义，如下所示：
```
public enum State {
    NEW,
    RUNNABLE,
    BLOCKED,
    WAITING,
    TIMED_WAITING,
    TIRMINATED;
}
```
&emsp;&emsp;NEW状态标识刚刚创建的线程，这种线程还没开始执行。等到线程的start()方法调用时，才表示线程开始执行。当线程执行时，处于RUNNABLE状态，表示线程所需的一切资源都已经准备好了。如果线程在执行过程中遇到了synchronized同步块，就会进入BLOCKED阻塞状态，这时线程就会暂停执行，直到获得请求的锁。WAITING和TIMED_WAITING都表示等待状态，**它们的区别是WAITING会进入一个无时间限制的等待，TIMED_WAITING会进行一个有时限的等待**。那等待的线程究竟在等什么呢？一般来说，WAITING的线程正是在等待一些特殊的事件。比如，通过wait()方法等待的线程在等待notify()方法，而通过join()方法等待的线程则会等待目标线程的终止。一旦等到了期望的事件，线程就会再次执行，进入RUNNABLE状态。当线程执行完毕后，则进入TERMINATED状态，表示结束。

&emsp;&emsp;**注意**：从NEW状态出发后，线程不能再回到NEW状态，同理，处于TERMINATED的线程也不能再回到RUNNALBE状态。