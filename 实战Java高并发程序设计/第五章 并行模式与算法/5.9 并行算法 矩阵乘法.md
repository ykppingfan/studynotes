&emsp;&emsp;我在第一章中已经提到，Linus认为并行程序目前只有在服务端程序和图像处理领域有发展的空间。且不论这种说法是否正确，但从中也可以看出并发对于这两个应用领域的重要性。而对于图像处理来说，矩阵运行是其中必不可少的重要数学方法。当然，除了图像处理，矩阵运算在神经网络、模式识别等领域也有着广泛的用途。在这里，我将向大家介绍矩阵运算的典型代表--矩阵乘法的并行化实现。

&emsp;&emsp;在矩阵乘法中，第一个矩阵的列数和第二个矩阵的函数必须是想吐的。如图5.16所示（图略，P226），矩阵A和矩阵B想成，其中矩阵A为4行2列，矩阵B为2行4列，他们相乘后，得到的是4行4列的矩阵，并且新矩阵中每一个元素为矩阵A和B对应行列的乘积求和。

&emsp;&emsp;如果需要进行并行计算，一种简单的策略是可以将A矩阵进行水平分割，得到子矩阵A1和A2，B矩阵进行垂直分割，得到子矩阵B1和B2。此时，我们只要分别计算这些子矩阵的乘积，将结果进行拼接，就能得到原始矩阵A和B的乘积。如图5.17所示（图略P226），展示了这种并行计算的策略。

&emsp;&emsp;当然，这个过程是可以反复进行的。为了计算A1* B1，我们还可以进一步将A1和B1进行分解，直到我们认为子矩阵的大小已经在可接受范围内。

&emsp;&emsp;这里，我们使用ForkJoin框架来实现这个并行矩阵相乘的想法。为了方便矩阵计算，我们使用jMatrices开源软件，作为矩阵计算的工具。其中，使用的主要API如下：

- Matrix：代表一个矩阵
- MatrixOperator.multiply(Matrix,Matrix)：矩阵相乘
- Matrix.row()：获得矩阵的行数
- Matrix.getSubMatrix()：获得矩阵的子矩阵
- MatrixOperator.horizontalConcatenation(matrix,Matrix)：将两个矩阵进行水平连接
- MatrixOperator.verticalConcatenation(Martrix,Matrix)：将两个矩阵进行垂直连接

&emsp;&emsp;为了计算矩阵乘法，定义一个任务类MatrixMulTask。它会进行矩阵相乘的计算，如果输入矩阵的粒度比较大，则会再次进行任务分解：
```
代码略
```
&emsp;&emsp;MatrixMulTask类由三个参数构成，分别是需要计算的矩阵双方，以及计算结果位于副矩阵相乘结果找那个的位置，如图5.18所示（图略 P229）。

&emsp;&emsp;MatrixMulTask中的成员变量m1和m2表示要相乘的两个矩阵，pos表示这个乘积结果在副矩阵相乘结果中所处的位置，有m1、m2、m3和m4等四中。代码第23~27行先对矩阵进行分割，分割后得到m11、m12、m21和m22等四个矩阵，并将他们按照如图5.18所示的规则进行子任务的创建。在第39~41行，计算这些子任务。在子任务返回后，在第42~48行将返回的四个矩阵m1、m2、m3和m4拼接成新的矩阵作为最终结果。

&emsp;&emsp;如果矩阵的粒度足够小就直接进行运算而不进行分解（第16行）。

&emsp;&emsp;使用这个任务类可以很容易地进行矩阵并行运算，下面是使用方法：
```
代码略
```
&emsp;&emsp;上述代码中第4~5行创建两个300*300的随机矩阵。构造矩阵计算任务MatrixMulTask并将其提交给ForkJoinPool线程池。第8行执行ForkJoinTask.get()方法等待并获得最终结果。