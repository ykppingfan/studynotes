### 本章主要内容

- 线程模型概述
- 事件循环的概念和实现
- 任务调度
- 实现细节

&emsp;&emsp;简单的说，线程模型指定了操作系统、编程语言、框架或者应用程序的上下文中的线程管理的关键方面。

&emsp;&emsp;在本章中，我们将详细地探讨Netty的线程模型。它强大但又易用，并且和Netty的一贯宗旨一样，旨在简化你的应用程序代码，同时最大限度地提高性能和可维护性。我们还将讨论致使选择当前线程模型的经验。

# 7.1 线程模型概述

&emsp;&emsp;在这一节中，我们将介绍常见的线程模型，随后将继续讨论Netty过去以及当前的线程模型，并评审它们各自的优点以及局限性。

&emsp;&emsp;因为具有多核心或多个CPU的计算机已经司空见惯，大多数的现代应用程序都利用了复杂的多线程处理技术以有效地利用系统资源。相比之下，在早期的Java语言中，我们使用多线程处理的主要方式无非是按需创建和启动新的Thread来执行并发的任务单元——一种在高负载下工作的很差的原始方式。Java5随后引入了Executor API，其线程池通过缓存和重用Thread极大的提高了性能。

&emsp;&emsp;基本的线程池化模式可以描述为：

- 从池的空闲线程列表中选择一个Thread，并且指派它去运行一个已提交的任务（一个Runnable的实现）;
- 当任务完成时，将该Thread返回给该列表，使其可被重用。

&emsp;&emsp;图7-1说明了这个模式。![image](http://img.blog.csdn.net/20160416101750275?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

&emsp;&emsp;虽然池化和重用线程相对于简单的为每个任务都创建和销毁线程是一种进步，但是它并不能消除由上下文切换所带来的开销，其将随着线程数量的增加很快变得明显，并且在高负载下愈演愈烈。此外，仅仅由于应用程序的整体复杂性或者并发需求，在项目的生命周期内也可能会出现其他和县城相关的问题。

&emsp;&emsp;简而言之，多线程处理是很复杂的。在接下来的章节中，我们将会看到Netty是如何帮助简化它的。