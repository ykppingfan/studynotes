&emsp;&emsp;**ChannelHandlerContext代表了ChannelHandler和ChannelPipeline之间的关联**，每当有ChannelHandler添加到ChannelPipeline中时，都会创建ChannelHandlerContext。ChannelHandlerContext的主要功能是管理它锁关联的ChannelHandler和在同一个ChannelPipeline中的其他ChannelHandler之间的交互。

&emsp;&emsp;ChannelHandlerContext有很多的方法，其中一些方法也存在于Channel的ChannelPipeline本身上，但是有一点重要的不同。如果调用Channel或者ChannelPipeline上的这些方法，它们将沿着整个ChannelPipeline进行传播。而调用位于ChannelHandlerContext上的相同的方法，则将从当前所关联的ChannelHandler开始，并且只会传播给位于该ChannelPipeline中的下一个能够处理该事件的ChannelHandler。

&emsp;&emsp;当使用ChannelHandlerContext的API的时候，请牢记以下两点：

- ChannelHandlerContext和ChannelHandler之间的关联（绑定）是永远不会改变的，所以缓存对它的引用是安全的；
- 如同我们在本节开头所解释的一样，相对于其他类的同名方法，ChannelHandlerContext的方法将产生更短的事件流，应该尽可能地利用这个特性来获得最大的性能。

## 6.3.1 使用ChannelHandlerContext

&emsp;&emsp;在这一节我们将讨论ChannelHandlerContext的用法，以及存在于ChannelHandlerContext、Channel和ChannelPipeline上的方法的行为。

&emsp;&emsp;它们之间的关系：Channel被绑定到ChannelPipeline；和Channel绑定的ChannelPipeline包含了所有的ChannelHandler；当把ChannelHandler添加到ChannelPipeline时，ChannelHandlerContext将被创建。

&emsp;&emsp;ctx.channel().write与ctx.pipeline().write方法的事件流是一样的，都将会导致写入时间从尾端到头部的流经整个ChannelPipeline。虽然被调用的Channel或ChannelPipeline上的write方法将一直传播时间通过整个ChannelPipeline，但是在ChannelHandler的级别上，事件从一个ChannleHandler到下一个ChannelHandler的移动是由ChannelHandlerContext上的调用完成的。

## 6.3.2 ChannelHandler和ChannelHandlerContext的高级用法

&emsp;&emsp;一个ChannelHandler可以从属于多个ChannelPipeline，所以它也可以绑定到多个ChannelHandlerContext实例。对于这种用法指在多个ChannelPipeline中共享一个ChannelHandler，对应的ChannelHandler必须要使用@Sharable注解标注；只有确认了你的ChannelHandler是线程安全时才使用@Sharable注解。

&emsp;&emsp;为何要共享一个ChannelHandler **在多个ChannelPipeline中安装同一个ChannelHandler的一个常见的原因是用于收集跨越多个Channel的统计信息**。